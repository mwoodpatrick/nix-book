== The hello-flake repo

Let’s clone the repository and see how the flake is defined.

....
$ cd ~/tutorial-practice
$ git clone https://codeberg.org/mhwombat/hello-flake
$ cd hello-flake
$ ls
....

This is a simple repo with just a few files. Like most git repos, it
includes `LICENSE`, which contains the software license, and `README.md`
which provides information about the repo.

The `hello-flake` file is the command we were executing earlier. This
particular executable is just a shell script, so we can view it. It’s an
extremly simple script with just two lines.

....
$ cat hello-flake
....

Now that we have a copy of the repo, we can execute this script
directly.

....
$ ./hello-flake
....

Not terribly exciting, I know. But starting with such a simple package
makes it easier to focus on the flake system without getting bogged down
in the details. We’ll make this script a little more interesting later.

Let’s look at another file. The file that defines how to package a flake
is always called `flake.nix`.

....
$ cat flake.nix
....

If this is your first time seeing a flake definition, it probably looks
intimidating. Flakes are written in a functional language called
Nixfootnote:[For an introduction to the Nix language, see
https://nixos.org/guides/nix-language.html[Nix language basics].]. Yes,
``Nix'' is the name of both the package manager and the language it
uses. We’ll look at this in more detail shortly. For now, I’d like to
focus on the inputs section.

....
inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };
....

There are just two entries, one for `nixpkgs` and one for `flake-utils`.
The first one, `nixpkgs` refers to the collection of standard software
packages that can be installed with the Nix package manager. The second,
`flake-utils`, is a collection of utilities that simplify writing
flakes. The important thing to note is that the `hello-flake` package
_depends_ on `nixpkgs` and `flake-utils`.

Finally, let’s look at `flake.lock`, or rather, just part of it.

....
$ head -n 40 flake.lock
....

If `flake.nix` seemed intimidating, then this file looks like an
invocation for Cthulhu. The good news is that this file is automatically
generated; you never need to write it. It contains information about all
of the dependencies for the flake, including where they came from, the
exact version/revision, and hash. This lockfile _uniquely_ specifies all
flake dependencies, (e.g., version number, branch, revision, hash), so
that _anyone, anywhere, any time, can re-create the exact same
environment that the original developer used._

No more complaints of ``but it works on my machine!''. That is the
benefit of using flakes.
